#include "globals.hpp"
#include "exploits.hpp"
#include "anti_aim.hpp"
#include "threads.hpp"
#include "engine_prediction.hpp"
#include "animations.hpp"
#include "server_bones.hpp"
#include "ragebot.hpp"
#include "cmd_shift.hpp"
#include "fake_lag.hpp"
#include "predfix.hpp"

/*
#ifndef _DEBUG
#include <VirtualizerSDK.h>
#endif
*/

void c_tickbase::store(int tickbase, int cmd, int shift, bool restore, int cmd_diff)
{
	auto& d = data;
	d.tickbase = tickbase;
	d.command_number = cmd;
	d.shift_amount = shift;
	d.restore_tickbase = restore;
	d.cmd_diff = cmd_diff;
}

void c_tickbase::fix(int new_command_number, int& tickbase)
{
	auto& d = data;
	if (d.command_number <= 0)
		return;

	auto viewmodel = (c_base_entity*)(HACKS->entity_list->get_client_entity_handle(HACKS->local->viewmodel()));
	if (!viewmodel)
		return;

	if (d.command_number == new_command_number)
	{
		viewmodel->anim_time() -= TICKS_TO_TIME(d.shift_amount + HACKS->global_vars->sim_ticks_this_frame);
		tickbase = d.tickbase - d.shift_amount + HACKS->global_vars->sim_ticks_this_frame;
	}

	if (d.restore_tickbase && d.command_number + d.cmd_diff == new_command_number)
	{
		viewmodel->anim_time() += TICKS_TO_TIME(d.shift_amount - HACKS->global_vars->sim_ticks_this_frame);
		tickbase += d.shift_amount - HACKS->global_vars->sim_ticks_this_frame;
	}
}

int c_exploits::get_instance_mode()
{
#ifdef LEGACY
	if (ANTI_AIM->is_fake_ducking() || g_cfg.binds[fd_b].toggled || g_cfg.binds[sw_b].toggled)
#else
	if (ANTI_AIM->is_fake_ducking() || g_cfg.binds[fd_b].toggled)
#endif
		return EXPLOITS_NONE;

	if (g_cfg.binds[dt_b].toggled)
		return EXPLOITS_DT;

	if (g_cfg.binds[hs_b].toggled)
		return EXPLOITS_HS;

	return EXPLOITS_NONE;
}

bool c_exploits::should_recharge()
{
	if (!available)
		return false;

	static int choke{};

	if (recharge.start && !choke)
	{
		if (recharge.charge_ticks <= 0)
		{
			recharge.start = false;
			recharge.finish = true;
			recharge.last_charge_tick = HACKS->cmd->command_number;

			return false;
		}

		recharge.finish = false;
		--recharge.charge_ticks;

		break_lc_tick = 0;
		execute_shift = false;

		return true;
	}
	else
		choke = HACKS->client_state->choked_commands;

	return false;
}

void c_exploits::update_exploit_mode()
{
	if (EXPLOITS->cl_move.trigger && EXPLOITS->cl_move.shifting)
		return;

	if (!available)
	{
		recharge.reset();
		return;
	}

	auto instance_mode = get_instance_mode();
	if (current_mode != instance_mode)
	{
		if (instance_mode == EXPLOITS_NONE)
		{
			if (!in_action && enabled())
			{
				cl_move.trigger = true;
				cl_move.shifting = false;
				cl_move.complete = false;
				cl_move.amount = limits.double_tap - 1;
			}

			recharge.reset();
			reset_dt = false;
			execute_shift = false;
			tick_to_shift_before = 0;
			break_lc_tick = 0;
			dt_bullet = 0;
			current_mode = instance_mode;
		}
		else
		{
			if (!recharge.start && !recharge.finish)
			{
				recharge.start = true;
				recharge.finish = false;
				recharge.charge_ticks = limits.recharge;
				recharge.fix_tickbase = true;

				execute_shift = false;
				in_action = false;
				reset_dt = false;
				dt_bullet = 0;
				break_lc_tick = 0;
			}

			current_mode = instance_mode;
		}
	}
}

inline bool is_peeking_for_exploits()
{
	return ANTI_AIM->is_peeking();
}

void c_exploits::update_instance()
{
	available = !(HACKS->local->flags().has(FL_FROZEN)) && !HACKS->local->has_gun_game_immunity();

	auto threaded_peeking = THREAD_POOL->add_task(is_peeking_for_exploits);
	auto result = std::any_cast<bool>(THREAD_POOL->wait_result(threaded_peeking));

	auto& best_player = RAGEBOT->best_rage_player;
	HACKS->can_peek = result || best_player.valid && best_player.best_point.found && best_player.best_point.predicted_eye_pos;

	limits.update();
	update_exploit_mode();

	if (!g_cfg.binds[ap_b].toggled)
		RAGEBOT->firing = false;
}

void c_exploits::run()
{
	if (!HACKS->weapon)
		return;

	if (EXPLOITS->cl_move.trigger && EXPLOITS->cl_move.shifting)
		return;

	if (current_mode == EXPLOITS_NONE || !enabled())
		return;

	if (std::abs(recharge.last_charge_tick - HACKS->cmd->command_number) < 2)
		return;

	switch (current_mode)
	{
	case EXPLOITS_DT:
	{
		if (reset_dt)
		{
			bool shot_finish = false;
			float shot_diff = std::abs(HACKS->weapon->last_shot_time() - HACKS->predicted_time);
			shot_finish = shot_diff >= 0.5f;

			auto shifting = cmd_shift::shifting || EXPLOITS->cl_move.trigger && EXPLOITS->cl_move.shifting;

			static int choke{};
			if (!shifting && shot_finish && !RAGEBOT->working && !choke)
			{
				recharge.start = true;
				recharge.finish = false;
				recharge.charge_ticks = limits.recharge;

				reset_dt = false;
				in_action = false;
			}
			else if (HACKS->cmd->buttons.has(IN_ATTACK))
				dt_bullet++;
			else
				choke = HACKS->client_state->choked_commands;

			return;
		}

		auto max_shift_amount = limits.double_tap;
		auto misc_weapon = HACKS->weapon->is_misc_weapon() && !HACKS->weapon->is_knife() && !HACKS->weapon->is_taser();

		if (!HACKS->weapon->is_grenade() && !misc_weapon && (RAGEBOT->is_shooting() || RAGEBOT->firing))
			break_lc_tick = HACKS->cmd->command_number;

		if (std::abs(break_lc_tick - HACKS->cmd->command_number) < 150 && !HACKS->client_state->choked_commands)
			execute_shift = true;

		if (execute_shift)
		{

			tick_to_shift = 0;

			cl_move.trigger = true;
			cl_move.shifting = false;
			cl_move.complete = false;
			cl_move.amount = limits.double_tap;

			reset_dt = true;
			in_action = true;
			execute_shift = false;
			dt_bullet++;

			defensive.tickbase_choke = 100;

			return;
		}

		auto start_defensive = !misc_weapon && HACKS->weapon->item_definition_index() != WEAPON_REVOLVER
			&& (HACKS->can_peek || g_cfg.rage.air_defensive && (!(HACKS->local->flags().has(FL_ONGROUND))));

		if (start_defensive)
		{
			if (defensive.tickbase_choke == 100)
			{
				tick_to_shift_before = max_shift_amount;
				tick_to_shift = max_shift_amount;
				defensive.tickbase_choke = 0;
			}
			else
			{
				if (defensive.tickbase_choke == 0)
				{
					tick_to_shift_before = 0;
					tick_to_shift = 0;

					*HACKS->send_packet = true;

					TICKBASE->store(HACKS->local->tickbase(), HACKS->cmd->command_number, -max_shift_amount + 1, false);

					++defensive.tickbase_choke;
				}
				else
				{
					tick_to_shift_before = max_shift_amount;
					tick_to_shift = max_shift_amount;

					if (defensive.tickbase_choke == 1 /*&& *g_ctx.send_packet*/ && tick_to_shift && shift_complete)
					{
						*HACKS->send_packet = true;

						TICKBASE->store(HACKS->local->tickbase(), HACKS->client_state->last_outgoing_command + HACKS->client_state->choked_commands + 1,
							max_shift_amount + 1, false);

						shift_complete = false;
					}
						
					if (++defensive.tickbase_choke > max_shift_amount + 1)
						defensive.tickbase_choke = 0;
				}
			}
		}
		else
		{
			defensive.tickbase_choke = 100;
			tick_to_shift = max_shift_amount;
			tick_to_shift_before = max_shift_amount;
		}

		in_action = false;
	}
	break;
	case EXPLOITS_HS:
	{
		tick_to_shift_before = limits.double_tap;

		if (HACKS->weapon->is_misc_weapon() || HACKS->weapon->item_definition_index() == WEAPON_REVOLVER)
		{
			in_action = false;
			return;
		}

		if ((RAGEBOT->firing || RAGEBOT->is_shooting()))
		{
			if (*HACKS->send_packet)
			{
				in_action = true;
				tick_to_shift = limits.hide_shots;

				TICKBASE->store(HACKS->local->tickbase(), HACKS->cmd->command_number, limits.hide_shots + 1, true);
			}
			else
			{
				HACKS->cmd->buttons.remove(IN_ATTACK);
				in_action = false;
			}
		}
		else
		{
			HACKS->cmd->buttons.remove(IN_ATTACK);
			in_action = false;
		}
	}
	break;
	}
}

void c_exploits::shift_clmove(float accumulated_extra_samples, bool final_tick)
{
	if (!HACKS->local || !HACKS->local->is_alive())
		return;

	if (!cl_move.trigger)
		return;

	static auto original = hooker::get_original(&hooks::detour::cl_move);

	*HACKS->send_packet = true;

	cl_move.complete = false;
	while (cl_move.amount >= 0)
	{
		ENGINE_PREDICTION->update();

		cl_move.shifting = true;
		original(0.f, cl_move.amount <= 0);

		cl_move.amount--;
	}

	cl_move.trigger = false;
	cl_move.shifting = false;
	cl_move.complete = true;

	if (!cl_move.finish_tick)
		cl_move.finish_tick = HACKS->cmd->command_number;
}

void write_user_cmd(void* buf, c_user_cmd* in, c_user_cmd* out)
{
	__asm
	{
		mov     ecx, buf
		mov     edx, in
		push    out
		call    offsets::write_user_cmd
		add     esp, 4
	}
}

bool c_exploits::should_shift_cmd(int* new_commands, int* backup_commands, void* ecx, void* edx, int slot, void* buf, int from, int to)
{
	static auto original = hooker::get_original(&hooks::vmt::write_usercmd_to_delta_buffer);

	auto newcmds = *new_commands;
	auto shift_amount = std::clamp(tick_to_shift, 1, limits.recharge);

	//break_lc_tick = HACKS->cmd->command_number;
	shift_complete = false;
	tick_to_shift = 0;
	*backup_commands = 0;

	auto choked_modifier = newcmds + shift_amount;

	if (choked_modifier > 62)
		choked_modifier = 62;

	*new_commands = choked_modifier;

	auto final_from = -1;
	auto next_cmdnr = HACKS->client_state->choked_commands + HACKS->client_state->last_outgoing_command + 1;
	auto final_to = next_cmdnr - newcmds + 1;

	if (final_to <= next_cmdnr)
	{
		while (original(ecx, edx, slot, buf, final_from, final_to, true))
		{
			final_from = final_to++;

			if (final_to > next_cmdnr)
				goto next_cmd;
		}

		return false;
	}
next_cmd:

	auto user_cmd = HACKS->input->get_user_cmd(final_from);

	if (!user_cmd)
		return true;

	c_user_cmd to_cmd{};
	c_user_cmd from_cmd{};

	from_cmd = *user_cmd;
	to_cmd = from_cmd;

	++to_cmd.command_number;
	to_cmd.tickcount = INT_MAX;
	do
	{
		write_user_cmd(buf, &to_cmd, &from_cmd);

		++to_cmd.command_number;
		shift_amount--;
	} while (shift_amount > 0);

	shift_complete = true;

	return true;
}